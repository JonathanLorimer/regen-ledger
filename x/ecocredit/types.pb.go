// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: regen/ecocredit/v1alpha1/types.proto

package ecocredit

import (
	fmt "fmt"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	github_com_gogo_protobuf_types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClassInfo represents the high-level on-chain information for a credit class.
type ClassInfo struct {
	// class_id is the unique ID of credit class.
	ClassId string `protobuf:"bytes,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// admin is the admin of the credit class.
	Admin string `protobuf:"bytes,2,opt,name=admin,proto3" json:"admin,omitempty"`
	// issuers are the approved issuers of the credit class.
	Issuers []string `protobuf:"bytes,3,rep,name=issuers,proto3" json:"issuers,omitempty"`
	// metadata is any arbitrary metadata to attached to the credit class.
	Metadata []byte `protobuf:"bytes,4,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// credit_type describes the type of credit (e.g. carbon, biodiversity), as well as unit and precision.
	CreditType *CreditType `protobuf:"bytes,5,opt,name=credit_type,json=creditType,proto3" json:"credit_type,omitempty"`
	// The number of batches issued in this credit class.
	NumBatches uint64 `protobuf:"varint,6,opt,name=num_batches,json=numBatches,proto3" json:"num_batches,omitempty"`
}

func (m *ClassInfo) Reset()         { *m = ClassInfo{} }
func (m *ClassInfo) String() string { return proto.CompactTextString(m) }
func (*ClassInfo) ProtoMessage()    {}
func (*ClassInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{0}
}
func (m *ClassInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClassInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClassInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClassInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClassInfo.Merge(m, src)
}
func (m *ClassInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClassInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClassInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClassInfo proto.InternalMessageInfo

func (m *ClassInfo) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *ClassInfo) GetAdmin() string {
	if m != nil {
		return m.Admin
	}
	return ""
}

func (m *ClassInfo) GetIssuers() []string {
	if m != nil {
		return m.Issuers
	}
	return nil
}

func (m *ClassInfo) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *ClassInfo) GetCreditType() *CreditType {
	if m != nil {
		return m.CreditType
	}
	return nil
}

func (m *ClassInfo) GetNumBatches() uint64 {
	if m != nil {
		return m.NumBatches
	}
	return 0
}

// BatchInfo represents the high-level on-chain information for a credit batch.
type BatchInfo struct {
	// class_id is the unique ID of credit class.
	ClassId string `protobuf:"bytes,1,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// batch_denom is the unique ID of credit batch.
	BatchDenom string `protobuf:"bytes,2,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// issuer is the issuer of the credit batch.
	Issuer string `protobuf:"bytes,3,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// total_amount is the total number of active credits in the credit batch.
	// Some of the issued credits may be cancelled and will be removed from
	// total_amount and tracked in amount_cancelled. total_amount and
	// amount_cancelled will always sum to the original amount of credits that
	// were issued.
	TotalAmount string `protobuf:"bytes,4,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	// metadata is any arbitrary metadata attached to the credit batch.
	Metadata []byte `protobuf:"bytes,5,opt,name=metadata,proto3" json:"metadata,omitempty"`
	// amount_cancelled is the number of credits in the batch that have been
	// cancelled, effectively undoing there issuance. The sum of total_amount and
	// amount_cancelled will always sum to the original amount of credits that
	// were issued.
	AmountCancelled string `protobuf:"bytes,6,opt,name=amount_cancelled,json=amountCancelled,proto3" json:"amount_cancelled,omitempty"`
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified.
	StartDate *time.Time `protobuf:"bytes,7,opt,name=start_date,json=startDate,proto3,stdtime" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified.
	EndDate *time.Time `protobuf:"bytes,8,opt,name=end_date,json=endDate,proto3,stdtime" json:"end_date,omitempty"`
	// project_location is the location of the project backing the credits in this
	// batch. Full documentation can be found in MsgCreateBatch.project_location.
	ProjectLocation string `protobuf:"bytes,9,opt,name=project_location,json=projectLocation,proto3" json:"project_location,omitempty"`
}

func (m *BatchInfo) Reset()         { *m = BatchInfo{} }
func (m *BatchInfo) String() string { return proto.CompactTextString(m) }
func (*BatchInfo) ProtoMessage()    {}
func (*BatchInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{1}
}
func (m *BatchInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchInfo.Merge(m, src)
}
func (m *BatchInfo) XXX_Size() int {
	return m.Size()
}
func (m *BatchInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BatchInfo proto.InternalMessageInfo

func (m *BatchInfo) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *BatchInfo) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *BatchInfo) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *BatchInfo) GetTotalAmount() string {
	if m != nil {
		return m.TotalAmount
	}
	return ""
}

func (m *BatchInfo) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *BatchInfo) GetAmountCancelled() string {
	if m != nil {
		return m.AmountCancelled
	}
	return ""
}

func (m *BatchInfo) GetStartDate() *time.Time {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *BatchInfo) GetEndDate() *time.Time {
	if m != nil {
		return m.EndDate
	}
	return nil
}

func (m *BatchInfo) GetProjectLocation() string {
	if m != nil {
		return m.ProjectLocation
	}
	return ""
}

// Params defines the updatable global parameters of the ecocredit module for
// use with the x/params module.
type Params struct {
	// credit_class_fee is the fixed fee charged on creation of a new credit class
	CreditClassFee github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,1,rep,name=credit_class_fee,json=creditClassFee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"credit_class_fee"`
	// allowed_class_creators is an allowlist defining the addresses with
	// the required permissions to create credit classes
	AllowedClassCreators []string `protobuf:"bytes,2,rep,name=allowed_class_creators,json=allowedClassCreators,proto3" json:"allowed_class_creators,omitempty"`
	// allowlist_enabled is a param that enables/disables the allowlist for credit
	// creation
	AllowlistEnabled bool `protobuf:"varint,3,opt,name=allowlist_enabled,json=allowlistEnabled,proto3" json:"allowlist_enabled,omitempty"`
	// credit_types is a list of definitions for credit types
	CreditTypes []*CreditType `protobuf:"bytes,4,rep,name=credit_types,json=creditTypes,proto3" json:"credit_types,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{2}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetCreditClassFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.CreditClassFee
	}
	return nil
}

func (m *Params) GetAllowedClassCreators() []string {
	if m != nil {
		return m.AllowedClassCreators
	}
	return nil
}

func (m *Params) GetAllowlistEnabled() bool {
	if m != nil {
		return m.AllowlistEnabled
	}
	return false
}

func (m *Params) GetCreditTypes() []*CreditType {
	if m != nil {
		return m.CreditTypes
	}
	return nil
}

// CreditType defines the measurement unit/precision of a certain credit type
// (e.g. carbon, biodiversity...)
type CreditType struct {
	// the type of credit (e.g. carbon, biodiversity, etc)
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// abbreviation is a 1-3 character uppercase abbreviation of the CreditType
	// name, used in batch denominations within the CreditType. It must be unique.
	Abbreviation string `protobuf:"bytes,2,opt,name=abbreviation,proto3" json:"abbreviation,omitempty"`
	// the measurement unit (e.g. kg, ton, etc)
	Unit string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
	// the decimal precision
	Precision uint32 `protobuf:"varint,4,opt,name=precision,proto3" json:"precision,omitempty"`
}

func (m *CreditType) Reset()         { *m = CreditType{} }
func (m *CreditType) String() string { return proto.CompactTextString(m) }
func (*CreditType) ProtoMessage()    {}
func (*CreditType) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{3}
}
func (m *CreditType) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreditType) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreditType.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreditType) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreditType.Merge(m, src)
}
func (m *CreditType) XXX_Size() int {
	return m.Size()
}
func (m *CreditType) XXX_DiscardUnknown() {
	xxx_messageInfo_CreditType.DiscardUnknown(m)
}

var xxx_messageInfo_CreditType proto.InternalMessageInfo

func (m *CreditType) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *CreditType) GetAbbreviation() string {
	if m != nil {
		return m.Abbreviation
	}
	return ""
}

func (m *CreditType) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *CreditType) GetPrecision() uint32 {
	if m != nil {
		return m.Precision
	}
	return 0
}

// CreditTypeSeq associates a sequence number with a credit type abbreviation.
// This represents the number of credit classes created with that credit type.
type CreditTypeSeq struct {
	// The credit type abbreviation
	Abbreviation string `protobuf:"bytes,1,opt,name=abbreviation,proto3" json:"abbreviation,omitempty"`
	// The sequence number of classes of the credit type
	SeqNumber uint64 `protobuf:"varint,2,opt,name=seq_number,json=seqNumber,proto3" json:"seq_number,omitempty"`
}

func (m *CreditTypeSeq) Reset()         { *m = CreditTypeSeq{} }
func (m *CreditTypeSeq) String() string { return proto.CompactTextString(m) }
func (*CreditTypeSeq) ProtoMessage()    {}
func (*CreditTypeSeq) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{4}
}
func (m *CreditTypeSeq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreditTypeSeq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreditTypeSeq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreditTypeSeq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreditTypeSeq.Merge(m, src)
}
func (m *CreditTypeSeq) XXX_Size() int {
	return m.Size()
}
func (m *CreditTypeSeq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreditTypeSeq.DiscardUnknown(m)
}

var xxx_messageInfo_CreditTypeSeq proto.InternalMessageInfo

func (m *CreditTypeSeq) GetAbbreviation() string {
	if m != nil {
		return m.Abbreviation
	}
	return ""
}

func (m *CreditTypeSeq) GetSeqNumber() uint64 {
	if m != nil {
		return m.SeqNumber
	}
	return 0
}

type Filter struct {
	// Types that are valid to be assigned to Sum:
	//	*Filter_And_
	//	*Filter_Or_
	Sum            isFilter_Sum `protobuf_oneof:"sum"`
	CreditTypeName string       `protobuf:"bytes,3,opt,name=credit_type_name,json=creditTypeName,proto3" json:"credit_type_name,omitempty"`
	ClassId        string       `protobuf:"bytes,4,opt,name=class_id,json=classId,proto3" json:"class_id,omitempty"`
	// project_id filters against credits from this batch.
	ProjectId string `protobuf:"bytes,5,opt,name=project_id,json=projectId,proto3" json:"project_id,omitempty"`
	// batch_id filters against credits from this batch.
	BatchDenom string `protobuf:"bytes,6,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// class_admin filters against credits issued by this class admin.
	ClassAdmin string `protobuf:"bytes,7,opt,name=class_admin,json=classAdmin,proto3" json:"class_admin,omitempty"`
	// issuer filters against credits issued by this issuer address.
	Issuer string `protobuf:"bytes,8,opt,name=issuer,proto3" json:"issuer,omitempty"`
	// owner filters against credits currently owned by this address.
	Owner string `protobuf:"bytes,9,opt,name=owner,proto3" json:"owner,omitempty"`
	// project_location can be specified in three levels of granularity:
	// country, sub-national-code, or postal code. If just country is given,
	// for instance "US" then any credits in the "US" will be matched even
	// their project location is more specific, ex. "US-NY 12345". If
	// a country, sub-national-code and postal code are all provided then
	// only projects in that postal code will match.
	ProjectLocation string            `protobuf:"bytes,10,opt,name=project_location,json=projectLocation,proto3" json:"project_location,omitempty"`
	DateRange       *Filter_DateRange `protobuf:"bytes,11,opt,name=date_range,json=dateRange,proto3" json:"date_range,omitempty"`
	// tag specifies a curation tag to match against.
	Tag string `protobuf:"bytes,12,opt,name=tag,proto3" json:"tag,omitempty"`
}

func (m *Filter) Reset()         { *m = Filter{} }
func (m *Filter) String() string { return proto.CompactTextString(m) }
func (*Filter) ProtoMessage()    {}
func (*Filter) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{5}
}
func (m *Filter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter.Merge(m, src)
}
func (m *Filter) XXX_Size() int {
	return m.Size()
}
func (m *Filter) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter.DiscardUnknown(m)
}

var xxx_messageInfo_Filter proto.InternalMessageInfo

type isFilter_Sum interface {
	isFilter_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Filter_And_ struct {
	And *Filter_And `protobuf:"bytes,1,opt,name=and,proto3,oneof" json:"and,omitempty"`
}
type Filter_Or_ struct {
	Or *Filter_Or `protobuf:"bytes,2,opt,name=or,proto3,oneof" json:"or,omitempty"`
}

func (*Filter_And_) isFilter_Sum() {}
func (*Filter_Or_) isFilter_Sum()  {}

func (m *Filter) GetSum() isFilter_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *Filter) GetAnd() *Filter_And {
	if x, ok := m.GetSum().(*Filter_And_); ok {
		return x.And
	}
	return nil
}

func (m *Filter) GetOr() *Filter_Or {
	if x, ok := m.GetSum().(*Filter_Or_); ok {
		return x.Or
	}
	return nil
}

func (m *Filter) GetCreditTypeName() string {
	if m != nil {
		return m.CreditTypeName
	}
	return ""
}

func (m *Filter) GetClassId() string {
	if m != nil {
		return m.ClassId
	}
	return ""
}

func (m *Filter) GetProjectId() string {
	if m != nil {
		return m.ProjectId
	}
	return ""
}

func (m *Filter) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *Filter) GetClassAdmin() string {
	if m != nil {
		return m.ClassAdmin
	}
	return ""
}

func (m *Filter) GetIssuer() string {
	if m != nil {
		return m.Issuer
	}
	return ""
}

func (m *Filter) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Filter) GetProjectLocation() string {
	if m != nil {
		return m.ProjectLocation
	}
	return ""
}

func (m *Filter) GetDateRange() *Filter_DateRange {
	if m != nil {
		return m.DateRange
	}
	return nil
}

func (m *Filter) GetTag() string {
	if m != nil {
		return m.Tag
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Filter) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Filter_And_)(nil),
		(*Filter_Or_)(nil),
	}
}

type Filter_And struct {
	Filters []*Filter `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
}

func (m *Filter_And) Reset()         { *m = Filter_And{} }
func (m *Filter_And) String() string { return proto.CompactTextString(m) }
func (*Filter_And) ProtoMessage()    {}
func (*Filter_And) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{5, 0}
}
func (m *Filter_And) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter_And) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter_And.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter_And) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter_And.Merge(m, src)
}
func (m *Filter_And) XXX_Size() int {
	return m.Size()
}
func (m *Filter_And) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter_And.DiscardUnknown(m)
}

var xxx_messageInfo_Filter_And proto.InternalMessageInfo

func (m *Filter_And) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

type Filter_Or struct {
	Filters []*Filter `protobuf:"bytes,1,rep,name=filters,proto3" json:"filters,omitempty"`
}

func (m *Filter_Or) Reset()         { *m = Filter_Or{} }
func (m *Filter_Or) String() string { return proto.CompactTextString(m) }
func (*Filter_Or) ProtoMessage()    {}
func (*Filter_Or) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{5, 1}
}
func (m *Filter_Or) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter_Or) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter_Or.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter_Or) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter_Or.Merge(m, src)
}
func (m *Filter_Or) XXX_Size() int {
	return m.Size()
}
func (m *Filter_Or) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter_Or.DiscardUnknown(m)
}

var xxx_messageInfo_Filter_Or proto.InternalMessageInfo

func (m *Filter_Or) GetFilters() []*Filter {
	if m != nil {
		return m.Filters
	}
	return nil
}

type Filter_DateRange struct {
	// start_date is the beginning of the period during which this credit batch
	// was quantified and verified. If it is empty then there is no start date
	// limit.
	StartDate *time.Time `protobuf:"bytes,7,opt,name=start_date,json=startDate,proto3,stdtime" json:"start_date,omitempty"`
	// end_date is the end of the period during which this credit batch was
	// quantified and verified. If it is empty then there is no end date
	// limit.
	EndDate *time.Time `protobuf:"bytes,8,opt,name=end_date,json=endDate,proto3,stdtime" json:"end_date,omitempty"`
}

func (m *Filter_DateRange) Reset()         { *m = Filter_DateRange{} }
func (m *Filter_DateRange) String() string { return proto.CompactTextString(m) }
func (*Filter_DateRange) ProtoMessage()    {}
func (*Filter_DateRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{5, 2}
}
func (m *Filter_DateRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Filter_DateRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Filter_DateRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Filter_DateRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Filter_DateRange.Merge(m, src)
}
func (m *Filter_DateRange) XXX_Size() int {
	return m.Size()
}
func (m *Filter_DateRange) XXX_DiscardUnknown() {
	xxx_messageInfo_Filter_DateRange.DiscardUnknown(m)
}

var xxx_messageInfo_Filter_DateRange proto.InternalMessageInfo

func (m *Filter_DateRange) GetStartDate() *time.Time {
	if m != nil {
		return m.StartDate
	}
	return nil
}

func (m *Filter_DateRange) GetEndDate() *time.Time {
	if m != nil {
		return m.EndDate
	}
	return nil
}

type BasketInfo struct {
	// basket_denom is the basket denom to add credits to.
	BasketDenom string `protobuf:"bytes,1,opt,name=basket_denom,json=basketDenom,proto3" json:"basket_denom,omitempty"`
	// display_name will be used to create a bank Metadata display name for this
	// basket token of the form ecocredit:{curator}:{display_name}.
	DisplayName string `protobuf:"bytes,3,opt,name=display_name,json=displayName,proto3" json:"display_name,omitempty"`
	// exponent is the exponent that will be used for denom metadata. An exponent
	// of 6 will mean that 10^6 units of a basket token should be displayed
	// as one unit in user interfaces.
	Exponent uint32 `protobuf:"varint,4,opt,name=exponent,proto3" json:"exponent,omitempty"`
	// admission_criteria is the criteria by which credits can be added to the
	// basket. Admission criteria will be applied in order and the first criteria
	// which applies to a credit will determine its multiplier in the basket.
	AdmissionCriteria []*AdmissionCriteria `protobuf:"bytes,5,rep,name=admission_criteria,json=admissionCriteria,proto3" json:"admission_criteria,omitempty"`
	RetireOnTake      bool                 `protobuf:"varint,6,opt,name=retire_on_take,json=retireOnTake,proto3" json:"retire_on_take,omitempty"`
	AllowPicking      bool                 `protobuf:"varint,7,opt,name=allow_picking,json=allowPicking,proto3" json:"allow_picking,omitempty"`
}

func (m *BasketInfo) Reset()         { *m = BasketInfo{} }
func (m *BasketInfo) String() string { return proto.CompactTextString(m) }
func (*BasketInfo) ProtoMessage()    {}
func (*BasketInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{6}
}
func (m *BasketInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasketInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasketInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasketInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasketInfo.Merge(m, src)
}
func (m *BasketInfo) XXX_Size() int {
	return m.Size()
}
func (m *BasketInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BasketInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BasketInfo proto.InternalMessageInfo

func (m *BasketInfo) GetBasketDenom() string {
	if m != nil {
		return m.BasketDenom
	}
	return ""
}

func (m *BasketInfo) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *BasketInfo) GetExponent() uint32 {
	if m != nil {
		return m.Exponent
	}
	return 0
}

func (m *BasketInfo) GetAdmissionCriteria() []*AdmissionCriteria {
	if m != nil {
		return m.AdmissionCriteria
	}
	return nil
}

func (m *BasketInfo) GetRetireOnTake() bool {
	if m != nil {
		return m.RetireOnTake
	}
	return false
}

func (m *BasketInfo) GetAllowPicking() bool {
	if m != nil {
		return m.AllowPicking
	}
	return false
}

type AdmissionCriteria struct {
	Filter *Filter `protobuf:"bytes,1,opt,name=filter,proto3" json:"filter,omitempty"`
	// multiplier is an integer number which is applied to credit units when
	// converting to basket units. For example if the multiplier is 2000, then
	// 1.1 credits will result in 2200 basket tokens. If there are any fractional
	// amounts left over in this calculation when adding credits to a basket,
	// those fractional amounts will not get added to the basket.
	Multiplier string `protobuf:"bytes,2,opt,name=multiplier,proto3" json:"multiplier,omitempty"`
}

func (m *AdmissionCriteria) Reset()         { *m = AdmissionCriteria{} }
func (m *AdmissionCriteria) String() string { return proto.CompactTextString(m) }
func (*AdmissionCriteria) ProtoMessage()    {}
func (*AdmissionCriteria) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{7}
}
func (m *AdmissionCriteria) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdmissionCriteria) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdmissionCriteria.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdmissionCriteria) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdmissionCriteria.Merge(m, src)
}
func (m *AdmissionCriteria) XXX_Size() int {
	return m.Size()
}
func (m *AdmissionCriteria) XXX_DiscardUnknown() {
	xxx_messageInfo_AdmissionCriteria.DiscardUnknown(m)
}

var xxx_messageInfo_AdmissionCriteria proto.InternalMessageInfo

func (m *AdmissionCriteria) GetFilter() *Filter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *AdmissionCriteria) GetMultiplier() string {
	if m != nil {
		return m.Multiplier
	}
	return ""
}

type BasketCredit struct {
	// batch_denom is the unique ID of the credit batch.
	BatchDenom string `protobuf:"bytes,1,opt,name=batch_denom,json=batchDenom,proto3" json:"batch_denom,omitempty"`
	// tradable_amount is the number of credits in this transfer that can be
	// traded by the recipient. Decimal values are acceptable within the
	// precision returned by Query/Precision.
	TradableAmount string `protobuf:"bytes,2,opt,name=tradable_amount,json=tradableAmount,proto3" json:"tradable_amount,omitempty"`
}

func (m *BasketCredit) Reset()         { *m = BasketCredit{} }
func (m *BasketCredit) String() string { return proto.CompactTextString(m) }
func (*BasketCredit) ProtoMessage()    {}
func (*BasketCredit) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{8}
}
func (m *BasketCredit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasketCredit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasketCredit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasketCredit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasketCredit.Merge(m, src)
}
func (m *BasketCredit) XXX_Size() int {
	return m.Size()
}
func (m *BasketCredit) XXX_DiscardUnknown() {
	xxx_messageInfo_BasketCredit.DiscardUnknown(m)
}

var xxx_messageInfo_BasketCredit proto.InternalMessageInfo

func (m *BasketCredit) GetBatchDenom() string {
	if m != nil {
		return m.BatchDenom
	}
	return ""
}

func (m *BasketCredit) GetTradableAmount() string {
	if m != nil {
		return m.TradableAmount
	}
	return ""
}

// BasketCredits is a type to describe an array of basket credits.
type BasketCredits struct {
	Credits []*BasketCredit `protobuf:"bytes,1,rep,name=credits,proto3" json:"credits,omitempty"`
}

func (m *BasketCredits) Reset()         { *m = BasketCredits{} }
func (m *BasketCredits) String() string { return proto.CompactTextString(m) }
func (*BasketCredits) ProtoMessage()    {}
func (*BasketCredits) Descriptor() ([]byte, []int) {
	return fileDescriptor_5342f4dcaeff1a84, []int{9}
}
func (m *BasketCredits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BasketCredits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BasketCredits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BasketCredits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BasketCredits.Merge(m, src)
}
func (m *BasketCredits) XXX_Size() int {
	return m.Size()
}
func (m *BasketCredits) XXX_DiscardUnknown() {
	xxx_messageInfo_BasketCredits.DiscardUnknown(m)
}

var xxx_messageInfo_BasketCredits proto.InternalMessageInfo

func (m *BasketCredits) GetCredits() []*BasketCredit {
	if m != nil {
		return m.Credits
	}
	return nil
}

func init() {
	proto.RegisterType((*ClassInfo)(nil), "regen.ecocredit.v1alpha1.ClassInfo")
	proto.RegisterType((*BatchInfo)(nil), "regen.ecocredit.v1alpha1.BatchInfo")
	proto.RegisterType((*Params)(nil), "regen.ecocredit.v1alpha1.Params")
	proto.RegisterType((*CreditType)(nil), "regen.ecocredit.v1alpha1.CreditType")
	proto.RegisterType((*CreditTypeSeq)(nil), "regen.ecocredit.v1alpha1.CreditTypeSeq")
	proto.RegisterType((*Filter)(nil), "regen.ecocredit.v1alpha1.Filter")
	proto.RegisterType((*Filter_And)(nil), "regen.ecocredit.v1alpha1.Filter.And")
	proto.RegisterType((*Filter_Or)(nil), "regen.ecocredit.v1alpha1.Filter.Or")
	proto.RegisterType((*Filter_DateRange)(nil), "regen.ecocredit.v1alpha1.Filter.DateRange")
	proto.RegisterType((*BasketInfo)(nil), "regen.ecocredit.v1alpha1.BasketInfo")
	proto.RegisterType((*AdmissionCriteria)(nil), "regen.ecocredit.v1alpha1.AdmissionCriteria")
	proto.RegisterType((*BasketCredit)(nil), "regen.ecocredit.v1alpha1.BasketCredit")
	proto.RegisterType((*BasketCredits)(nil), "regen.ecocredit.v1alpha1.BasketCredits")
}

func init() {
	proto.RegisterFile("regen/ecocredit/v1alpha1/types.proto", fileDescriptor_5342f4dcaeff1a84)
}

var fileDescriptor_5342f4dcaeff1a84 = []byte{
	// 1152 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x4f, 0x6f, 0x13, 0x47,
	0x14, 0xcf, 0xda, 0x8e, 0xed, 0x7d, 0x76, 0x42, 0x18, 0x45, 0x68, 0xb1, 0x8a, 0x6d, 0x0c, 0x6a,
	0x4d, 0x11, 0xeb, 0x86, 0xb6, 0x12, 0x6a, 0x0f, 0x25, 0x09, 0x50, 0x50, 0x2b, 0xa0, 0x5b, 0x0e,
	0x15, 0x97, 0xd5, 0x78, 0xf7, 0xc5, 0x6c, 0xb3, 0x3b, 0x63, 0x66, 0xc6, 0x01, 0x3e, 0x42, 0x6f,
	0x5c, 0xfa, 0x25, 0xda, 0x2f, 0xc2, 0x91, 0x63, 0xd5, 0x43, 0xa9, 0xe0, 0xdc, 0x4b, 0x3f, 0x41,
	0x35, 0x7f, 0xd6, 0x76, 0x08, 0x69, 0x90, 0x7a, 0xe8, 0xc9, 0xf3, 0x7e, 0x33, 0xbf, 0x79, 0xfb,
	0xde, 0xfb, 0xbd, 0x37, 0x86, 0x8b, 0x02, 0x27, 0xc8, 0x46, 0x98, 0xf0, 0x44, 0x60, 0x9a, 0xa9,
	0xd1, 0xc1, 0x16, 0xcd, 0xa7, 0x8f, 0xe8, 0xd6, 0x48, 0x3d, 0x9b, 0xa2, 0x0c, 0xa7, 0x82, 0x2b,
	0x4e, 0x02, 0x73, 0x2a, 0x9c, 0x9f, 0x0a, 0xcb, 0x53, 0x9d, 0x6e, 0xc2, 0x65, 0xc1, 0xe5, 0x68,
	0x4c, 0x25, 0x8e, 0x0e, 0xb6, 0xc6, 0xa8, 0xe8, 0xd6, 0x28, 0xe1, 0x19, 0xb3, 0xcc, 0xce, 0xe6,
	0x84, 0x4f, 0xb8, 0x59, 0x8e, 0xf4, 0xca, 0xa1, 0xbd, 0x09, 0xe7, 0x93, 0x1c, 0x47, 0xc6, 0x1a,
	0xcf, 0xf6, 0x46, 0x2a, 0x2b, 0x50, 0x2a, 0x5a, 0x4c, 0xed, 0x81, 0xc1, 0xef, 0x1e, 0xf8, 0xbb,
	0x39, 0x95, 0xf2, 0x0e, 0xdb, 0xe3, 0xe4, 0x2c, 0x34, 0x13, 0x6d, 0xc4, 0x59, 0x1a, 0x78, 0x7d,
	0x6f, 0xe8, 0x47, 0x0d, 0x63, 0xdf, 0x49, 0xc9, 0x26, 0xac, 0xd2, 0xb4, 0xc8, 0x58, 0x50, 0x31,
	0xb8, 0x35, 0x48, 0x00, 0x8d, 0x4c, 0xca, 0x19, 0x0a, 0x19, 0x54, 0xfb, 0x55, 0x7d, 0xde, 0x99,
	0xa4, 0x03, 0xcd, 0x02, 0x15, 0x4d, 0xa9, 0xa2, 0x41, 0xad, 0xef, 0x0d, 0xdb, 0xd1, 0xdc, 0x26,
	0x37, 0xa1, 0x65, 0xc3, 0x8b, 0x75, 0xec, 0xc1, 0x6a, 0xdf, 0x1b, 0xb6, 0xae, 0x5e, 0x0c, 0x8f,
	0x8b, 0x3d, 0xdc, 0x35, 0xf6, 0x83, 0x67, 0x53, 0x8c, 0x20, 0x99, 0xaf, 0x49, 0x0f, 0x5a, 0x6c,
	0x56, 0xc4, 0x63, 0xaa, 0x92, 0x47, 0x28, 0x83, 0x7a, 0xdf, 0x1b, 0xd6, 0x22, 0x60, 0xb3, 0x62,
	0xc7, 0x22, 0x83, 0xbf, 0x2b, 0xe0, 0x9b, 0xf5, 0x49, 0xc1, 0xf5, 0xa0, 0x65, 0x6e, 0x89, 0x53,
	0x64, 0xbc, 0x70, 0x21, 0x82, 0x81, 0x6e, 0x68, 0x84, 0x9c, 0x81, 0xba, 0x0d, 0x2c, 0xa8, 0x9a,
	0x3d, 0x67, 0x91, 0xf3, 0xd0, 0x56, 0x5c, 0xd1, 0x3c, 0xa6, 0x05, 0x9f, 0x31, 0x65, 0x22, 0xf5,
	0xa3, 0x96, 0xc1, 0xb6, 0x0d, 0x74, 0x28, 0x11, 0xab, 0x6f, 0x25, 0xe2, 0x12, 0x6c, 0x58, 0x62,
	0x9c, 0x50, 0x96, 0x60, 0x9e, 0x63, 0x6a, 0xc2, 0xf0, 0xa3, 0x53, 0x16, 0xdf, 0x2d, 0x61, 0xf2,
	0x15, 0x80, 0x54, 0x54, 0xa8, 0x38, 0xa5, 0x0a, 0x83, 0x86, 0x49, 0x59, 0x27, 0xb4, 0xe5, 0x0d,
	0xcb, 0xf2, 0x86, 0x0f, 0xca, 0xf2, 0xee, 0xd4, 0x9e, 0xbf, 0xea, 0x79, 0x91, 0x6f, 0x38, 0x37,
	0xa8, 0x42, 0xf2, 0x25, 0x34, 0x91, 0xa5, 0x96, 0xde, 0x7c, 0x4f, 0x7a, 0x03, 0x59, 0x6a, 0xc8,
	0x97, 0x60, 0x63, 0x2a, 0xf8, 0x8f, 0x98, 0xa8, 0x38, 0xe7, 0x09, 0x55, 0x19, 0x67, 0x81, 0x6f,
	0x3f, 0xd4, 0xe1, 0xdf, 0x3a, 0x78, 0xf0, 0x6b, 0x05, 0xea, 0xf7, 0xa9, 0xa0, 0x85, 0x24, 0x33,
	0xd8, 0x70, 0x75, 0xb6, 0x89, 0xdf, 0x43, 0x0c, 0xbc, 0x7e, 0x75, 0xd8, 0xba, 0x7a, 0x36, 0xb4,
	0x72, 0x0e, 0xb5, 0x9c, 0x43, 0x27, 0xe7, 0x70, 0x97, 0x67, 0x6c, 0xe7, 0x93, 0x17, 0x7f, 0xf4,
	0x56, 0x7e, 0x79, 0xd5, 0x1b, 0x4e, 0x32, 0xf5, 0x68, 0x36, 0x0e, 0x13, 0x5e, 0x8c, 0x9c, 0xf6,
	0xed, 0xcf, 0x15, 0x99, 0xee, 0xbb, 0xa6, 0xd1, 0x04, 0x19, 0xad, 0x5b, 0x27, 0x46, 0xc6, 0xb7,
	0x10, 0xc9, 0x67, 0x70, 0x86, 0xe6, 0x39, 0x7f, 0x82, 0xa9, 0xf3, 0x9b, 0x08, 0xa4, 0x8a, 0x0b,
	0x19, 0x54, 0x8c, 0x46, 0x37, 0xdd, 0xae, 0x21, 0xec, 0xba, 0x3d, 0x72, 0x19, 0x4e, 0x1b, 0x3c,
	0xcf, 0xa4, 0x8a, 0x91, 0xd1, 0xb1, 0x2e, 0x86, 0xae, 0x76, 0x33, 0xda, 0x98, 0x6f, 0xdc, 0xb4,
	0x38, 0xf9, 0x1a, 0xda, 0x4b, 0x0a, 0x96, 0x41, 0xcd, 0x44, 0xf5, 0x7e, 0x12, 0x6e, 0x2d, 0x24,
	0x2c, 0x07, 0x07, 0x00, 0x8b, 0x2d, 0x42, 0xa0, 0xc6, 0x68, 0x81, 0x4e, 0x9e, 0x66, 0x4d, 0x06,
	0xd0, 0xa6, 0xe3, 0xb1, 0xc0, 0x83, 0xcc, 0xa6, 0xdd, 0x8a, 0xf3, 0x10, 0xa6, 0x79, 0x33, 0x96,
	0x29, 0x27, 0x4e, 0xb3, 0x26, 0x1f, 0x80, 0x3f, 0x15, 0x98, 0x64, 0x52, 0x93, 0xb4, 0x2e, 0xd7,
	0xa2, 0x05, 0x30, 0x88, 0x60, 0x6d, 0xe1, 0xf7, 0x7b, 0x7c, 0x7c, 0xc4, 0x8d, 0xf7, 0x0e, 0x37,
	0xe7, 0x00, 0x24, 0x3e, 0x8e, 0xd9, 0xac, 0x18, 0xa3, 0x30, 0x1f, 0x52, 0x8b, 0x7c, 0x89, 0x8f,
	0xef, 0x1a, 0x60, 0xf0, 0xd7, 0x2a, 0xd4, 0x6f, 0x65, 0xb9, 0x42, 0x41, 0xae, 0x41, 0x95, 0x32,
	0xdb, 0x66, 0xff, 0x9a, 0x16, 0x7b, 0x3c, 0xdc, 0x66, 0xe9, 0xed, 0x95, 0x48, 0x53, 0xc8, 0xe7,
	0x50, 0xe1, 0xf6, 0xee, 0xd6, 0xd5, 0x0b, 0x27, 0x12, 0xef, 0x89, 0xdb, 0x2b, 0x51, 0x85, 0x0b,
	0x32, 0x9c, 0x4b, 0x4d, 0x17, 0x24, 0x36, 0x59, 0xb4, 0xd9, 0x58, 0x5f, 0xa4, 0xfb, 0xae, 0xce,
	0xe7, 0xf2, 0x18, 0xa8, 0x1d, 0x1e, 0x03, 0xe7, 0x00, 0x4a, 0x95, 0x67, 0xa9, 0x69, 0x56, 0x5f,
	0xe7, 0xcc, 0x20, 0x47, 0xa7, 0x44, 0xfd, 0xc8, 0x94, 0xe8, 0x41, 0xcb, 0x5e, 0x6d, 0x27, 0x65,
	0xc3, 0x1e, 0x30, 0xd0, 0xb6, 0x19, 0x97, 0x8b, 0x31, 0xd2, 0x3c, 0x34, 0x46, 0x36, 0x61, 0x95,
	0x3f, 0x61, 0x28, 0x5c, 0x4f, 0x59, 0xe3, 0x9d, 0x4d, 0x07, 0xef, 0x6c, 0x3a, 0x72, 0x07, 0x40,
	0x37, 0x76, 0x2c, 0x28, 0x9b, 0x60, 0xd0, 0x32, 0xd9, 0xfb, 0xf8, 0xc4, 0xec, 0xe9, 0xd6, 0x8e,
	0x34, 0x23, 0xf2, 0xd3, 0x72, 0x49, 0x36, 0xa0, 0xaa, 0xe8, 0x24, 0x68, 0x1b, 0x47, 0x7a, 0xd9,
	0xd9, 0x86, 0xea, 0x36, 0x4b, 0xc9, 0x17, 0xd0, 0xd8, 0x33, 0x3c, 0xe9, 0x9a, 0xb8, 0x7f, 0x92,
	0x83, 0xa8, 0x24, 0x74, 0xae, 0x43, 0xe5, 0x9e, 0xf8, 0x4f, 0x37, 0xfc, 0xe4, 0x81, 0x3f, 0xff,
	0xde, 0xff, 0x77, 0x1a, 0xee, 0xac, 0x42, 0x55, 0xce, 0x8a, 0xc1, 0xcf, 0x15, 0x80, 0x1d, 0x2a,
	0xf7, 0x51, 0x99, 0xf7, 0xe5, 0x3c, 0xb4, 0xc7, 0xc6, 0x72, 0xfa, 0xb0, 0x1d, 0xd4, 0xb2, 0x98,
	0x15, 0xc8, 0x79, 0x68, 0xa7, 0x99, 0x9c, 0xe6, 0xf4, 0xd9, 0xb2, 0x42, 0x5b, 0x0e, 0x33, 0xf2,
	0xec, 0x40, 0x13, 0x9f, 0x4e, 0x39, 0x43, 0xf7, 0x9a, 0xac, 0x45, 0x73, 0x9b, 0x3c, 0x04, 0xa2,
	0x95, 0x25, 0x75, 0x07, 0xc7, 0x89, 0xc8, 0x14, 0x8a, 0x4c, 0x3f, 0x2a, 0x3a, 0x95, 0x97, 0x8f,
	0x4f, 0xe5, 0x76, 0xc9, 0xd9, 0x75, 0x94, 0xe8, 0x34, 0x7d, 0x1b, 0x22, 0x17, 0x61, 0x5d, 0xa0,
	0xca, 0x04, 0xc6, 0x9c, 0xc5, 0x8a, 0xee, 0xa3, 0xd1, 0x77, 0x33, 0x6a, 0x5b, 0xf4, 0x1e, 0x7b,
	0x40, 0xf7, 0x91, 0x5c, 0x80, 0x35, 0x33, 0x0b, 0xe3, 0x69, 0x96, 0xec, 0x67, 0x6c, 0x62, 0x52,
	0xdf, 0x8c, 0xda, 0x06, 0xbc, 0x6f, 0xb1, 0x41, 0x01, 0xa7, 0x8f, 0xb8, 0x24, 0xd7, 0xa0, 0x6e,
	0x4b, 0xe9, 0x86, 0xc2, 0xc9, 0xa5, 0x77, 0xe7, 0x49, 0x17, 0xa0, 0x98, 0xe5, 0x2a, 0x9b, 0xe6,
	0x99, 0x9b, 0x3a, 0x7e, 0xb4, 0x84, 0x0c, 0x7e, 0x80, 0xb6, 0xad, 0x82, 0x1d, 0x68, 0x6f, 0xb7,
	0xa9, 0x77, 0xa4, 0x4d, 0x3f, 0x82, 0x53, 0x4a, 0xd0, 0x54, 0x4f, 0xf2, 0xf2, 0xdd, 0xb6, 0xb7,
	0xae, 0x97, 0xb0, 0x7d, 0xba, 0x07, 0xdf, 0xc1, 0xda, 0xf2, 0xcd, 0x92, 0x5c, 0x87, 0x86, 0xfd,
	0xd8, 0x52, 0xc0, 0x1f, 0x1e, 0x1f, 0xc5, 0x32, 0x33, 0x2a, 0x69, 0x3b, 0xdf, 0xbc, 0x78, 0xdd,
	0xf5, 0x5e, 0xbe, 0xee, 0x7a, 0x7f, 0xbe, 0xee, 0x7a, 0xcf, 0xdf, 0x74, 0x57, 0x5e, 0xbe, 0xe9,
	0xae, 0xfc, 0xf6, 0xa6, 0xbb, 0xf2, 0x70, 0x6b, 0xe9, 0xbd, 0x33, 0x97, 0x5e, 0x61, 0xa8, 0x9e,
	0x70, 0xb1, 0xef, 0xac, 0x1c, 0xd3, 0x09, 0x8a, 0xd1, 0xd3, 0xc5, 0x5f, 0xc8, 0x71, 0xdd, 0x48,
	0xf5, 0xd3, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x45, 0x78, 0xf7, 0x60, 0x5c, 0x0a, 0x00, 0x00,
}

func (m *ClassInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClassInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClassInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NumBatches != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumBatches))
		i--
		dAtA[i] = 0x30
	}
	if m.CreditType != nil {
		{
			size, err := m.CreditType.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Issuers) > 0 {
		for iNdEx := len(m.Issuers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Issuers[iNdEx])
			copy(dAtA[i:], m.Issuers[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Issuers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Admin) > 0 {
		i -= len(m.Admin)
		copy(dAtA[i:], m.Admin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Admin)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProjectLocation) > 0 {
		i -= len(m.ProjectLocation)
		copy(dAtA[i:], m.ProjectLocation)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectLocation)))
		i--
		dAtA[i] = 0x4a
	}
	if m.EndDate != nil {
		n2, err2 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndDate):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintTypes(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x42
	}
	if m.StartDate != nil {
		n3, err3 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartDate):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintTypes(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.AmountCancelled) > 0 {
		i -= len(m.AmountCancelled)
		copy(dAtA[i:], m.AmountCancelled)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AmountCancelled)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TotalAmount) > 0 {
		i -= len(m.TotalAmount)
		copy(dAtA[i:], m.TotalAmount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TotalAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CreditTypes) > 0 {
		for iNdEx := len(m.CreditTypes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CreditTypes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AllowlistEnabled {
		i--
		if m.AllowlistEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.AllowedClassCreators) > 0 {
		for iNdEx := len(m.AllowedClassCreators) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedClassCreators[iNdEx])
			copy(dAtA[i:], m.AllowedClassCreators[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedClassCreators[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.CreditClassFee) > 0 {
		for iNdEx := len(m.CreditClassFee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CreditClassFee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreditType) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreditType) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreditType) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Precision != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Precision))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Abbreviation) > 0 {
		i -= len(m.Abbreviation)
		copy(dAtA[i:], m.Abbreviation)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Abbreviation)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreditTypeSeq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreditTypeSeq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreditTypeSeq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SeqNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Abbreviation) > 0 {
		i -= len(m.Abbreviation)
		copy(dAtA[i:], m.Abbreviation)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Abbreviation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Filter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tag) > 0 {
		i -= len(m.Tag)
		copy(dAtA[i:], m.Tag)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Tag)))
		i--
		dAtA[i] = 0x62
	}
	if m.DateRange != nil {
		{
			size, err := m.DateRange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ProjectLocation) > 0 {
		i -= len(m.ProjectLocation)
		copy(dAtA[i:], m.ProjectLocation)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectLocation)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Issuer) > 0 {
		i -= len(m.Issuer)
		copy(dAtA[i:], m.Issuer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Issuer)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ClassAdmin) > 0 {
		i -= len(m.ClassAdmin)
		copy(dAtA[i:], m.ClassAdmin)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassAdmin)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ProjectId) > 0 {
		i -= len(m.ProjectId)
		copy(dAtA[i:], m.ProjectId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProjectId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClassId) > 0 {
		i -= len(m.ClassId)
		copy(dAtA[i:], m.ClassId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClassId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CreditTypeName) > 0 {
		i -= len(m.CreditTypeName)
		copy(dAtA[i:], m.CreditTypeName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CreditTypeName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter_And_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_And_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.And != nil {
		{
			size, err := m.And.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Filter_Or_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_Or_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Or != nil {
		{
			size, err := m.Or.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Filter_And) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter_And) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_And) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter_Or) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter_Or) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_Or) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for iNdEx := len(m.Filters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Filters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Filter_DateRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Filter_DateRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Filter_DateRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndDate != nil {
		n7, err7 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.EndDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndDate):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintTypes(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x42
	}
	if m.StartDate != nil {
		n8, err8 := github_com_gogo_protobuf_types.StdTimeMarshalTo(*m.StartDate, dAtA[i-github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartDate):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintTypes(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}

func (m *BasketInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasketInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasketInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowPicking {
		i--
		if m.AllowPicking {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RetireOnTake {
		i--
		if m.RetireOnTake {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.AdmissionCriteria) > 0 {
		for iNdEx := len(m.AdmissionCriteria) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AdmissionCriteria[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Exponent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Exponent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.BasketDenom) > 0 {
		i -= len(m.BasketDenom)
		copy(dAtA[i:], m.BasketDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BasketDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdmissionCriteria) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdmissionCriteria) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdmissionCriteria) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Multiplier) > 0 {
		i -= len(m.Multiplier)
		copy(dAtA[i:], m.Multiplier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Multiplier)))
		i--
		dAtA[i] = 0x12
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BasketCredit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasketCredit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasketCredit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TradableAmount) > 0 {
		i -= len(m.TradableAmount)
		copy(dAtA[i:], m.TradableAmount)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TradableAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BatchDenom) > 0 {
		i -= len(m.BatchDenom)
		copy(dAtA[i:], m.BatchDenom)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BatchDenom)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BasketCredits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BasketCredits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BasketCredits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for iNdEx := len(m.Credits) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Credits[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClassInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Admin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Issuers) > 0 {
		for _, s := range m.Issuers {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreditType != nil {
		l = m.CreditType.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NumBatches != 0 {
		n += 1 + sovTypes(uint64(m.NumBatches))
	}
	return n
}

func (m *BatchInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TotalAmount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AmountCancelled)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StartDate != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartDate)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndDate != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndDate)
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectLocation)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.CreditClassFee) > 0 {
		for _, e := range m.CreditClassFee {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.AllowedClassCreators) > 0 {
		for _, s := range m.AllowedClassCreators {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AllowlistEnabled {
		n += 2
	}
	if len(m.CreditTypes) > 0 {
		for _, e := range m.CreditTypes {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *CreditType) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Abbreviation)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Precision != 0 {
		n += 1 + sovTypes(uint64(m.Precision))
	}
	return n
}

func (m *CreditTypeSeq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Abbreviation)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SeqNumber != 0 {
		n += 1 + sovTypes(uint64(m.SeqNumber))
	}
	return n
}

func (m *Filter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	l = len(m.CreditTypeName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClassId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClassAdmin)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Issuer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProjectLocation)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DateRange != nil {
		l = m.DateRange.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Tag)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Filter_And_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.And != nil {
		l = m.And.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Filter_Or_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Or != nil {
		l = m.Or.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Filter_And) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Filter_Or) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Filters) > 0 {
		for _, e := range m.Filters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Filter_DateRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartDate != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.StartDate)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndDate != nil {
		l = github_com_gogo_protobuf_types.SizeOfStdTime(*m.EndDate)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BasketInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BasketDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Exponent != 0 {
		n += 1 + sovTypes(uint64(m.Exponent))
	}
	if len(m.AdmissionCriteria) > 0 {
		for _, e := range m.AdmissionCriteria {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.RetireOnTake {
		n += 2
	}
	if m.AllowPicking {
		n += 2
	}
	return n
}

func (m *AdmissionCriteria) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Multiplier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BasketCredit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BatchDenom)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TradableAmount)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *BasketCredits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Credits) > 0 {
		for _, e := range m.Credits {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClassInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClassInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClassInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Admin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Admin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuers = append(m.Issuers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreditType == nil {
				m.CreditType = &CreditType{}
			}
			if err := m.CreditType.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBatches", wireType)
			}
			m.NumBatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBatches |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AmountCancelled", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AmountCancelled = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditClassFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditClassFee = append(m.CreditClassFee, types1.Coin{})
			if err := m.CreditClassFee[len(m.CreditClassFee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedClassCreators", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedClassCreators = append(m.AllowedClassCreators, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowlistEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowlistEnabled = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypes = append(m.CreditTypes, &CreditType{})
			if err := m.CreditTypes[len(m.CreditTypes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreditType) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreditType: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreditType: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abbreviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abbreviation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Precision", wireType)
			}
			m.Precision = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Precision |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreditTypeSeq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreditTypeSeq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreditTypeSeq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Abbreviation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Abbreviation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNumber", wireType)
			}
			m.SeqNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Filter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Filter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field And", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter_And{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Filter_And_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Or", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Filter_Or{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Filter_Or_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreditTypeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreditTypeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClassAdmin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClassAdmin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Issuer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Issuer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProjectLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProjectLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DateRange == nil {
				m.DateRange = &Filter_DateRange{}
			}
			if err := m.DateRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter_And) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: And: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: And: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter_Or) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Or: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Or: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filters = append(m.Filters, &Filter{})
			if err := m.Filters[len(m.Filters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Filter_DateRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DateRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DateRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartDate == nil {
				m.StartDate = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.StartDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndDate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndDate == nil {
				m.EndDate = new(time.Time)
			}
			if err := github_com_gogo_protobuf_types.StdTimeUnmarshal(m.EndDate, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasketInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasketInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasketInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasketDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BasketDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exponent", wireType)
			}
			m.Exponent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Exponent |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdmissionCriteria", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AdmissionCriteria = append(m.AdmissionCriteria, &AdmissionCriteria{})
			if err := m.AdmissionCriteria[len(m.AdmissionCriteria)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetireOnTake", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RetireOnTake = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowPicking", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowPicking = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdmissionCriteria) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdmissionCriteria: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdmissionCriteria: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &Filter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Multiplier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasketCredit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasketCredit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasketCredit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BatchDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradableAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TradableAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BasketCredits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BasketCredits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BasketCredits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Credits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Credits = append(m.Credits, &BasketCredit{})
			if err := m.Credits[len(m.Credits)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
